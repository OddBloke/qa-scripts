#!/usr/bin/env python3
'''Launch an instance on softlayer to test cloud-init'''

# see 'check_deps' below for non-standard lib imports.

from argparse import ArgumentParser
import datetime
import os
import shutil
import sys
from subprocess import (PIPE, Popen, check_output)
import time
import uuid

_missing_deps = []

try:
    import SoftLayer
    from SoftLayer.utils import is_ready
except ImportError:
    _missing_deps.append('SoftLayer')
try:
    import petname
except ImportError:
    _missing_deps.append('petname')

if _missing_deps:
    sys.stderr.write(
        "Missing dependencies.  Install with:\n  pip install %s\n" %
        ' '.join(_missing_deps))
    sys.exit(1)


PUBLIC_IMAGE_ACCOUNT_ID = 208938
DEFAULT_REGION = 'dal05'
DEFAULT_FLAVOR = 'B1_1X4X100'
DEFAULT_FLAVOR = 'C1_1X1X25'
DEFAULT_SERIES = 'bionic'
SECGROUP_NAME = 'Cloud-init integration test secgroup'
SECGROUP_DESCRIPTION = 'Security group setting ssh ingress to instances'

UBUNTU_VERSIONS = {'trusty': '14.04', 'xenial': '16.04', 'bionic': '18.04'}

# Directory where script artifacts can be saved for sync
DEFAULT_LOCAL_ARTIFACT_DIR = 'test-artifacts'
REMOTE_ARTIFACT_DIR = '/tmp/cloud-init-script-artifacts'

REGIONS = (
    "ams01",
    "ams03",
    "che01",
    "dal01",
    "dal05",
    "dal06",
    "dal09",
    "dal10",
    "dal12",
    "dal13",
    "fra02",
    "hkg02",
    "hou02",
    "lon02",
    "lon04",
    "lon06",
    "mel01",
    "mex01",
    "mil01",
    "mon01",
    "osl01",
    "par01",
    "sao01",
    "sea01",
    "seo01",
    "sjc01",
    "sjc03",
    "sjc04",
    "sng01",
    "syd01",
    "syd04",
    "tok02",
    "tor01",
    "wdc01",
    "wdc04",
    "wdc06",
    "wdc07",
)

FLAVORS = (
    "B1_1X4X100",
    "B1_16X64X100",
    "B1_2X8X100",
    "B1_4X8X100",
    "B1_1X2X25",
    "B1_1X4X25",
    "B1_2X4X25",
    "B1_2X8X25",
    "B1_4X8X25",
    "B1_4X16X25",
    "B1_8X16X25",
    "B1_8X32X25",
    "B1_16X32X25",
    "B1_16X64X25",
    "B1_32X64X25",
    "B1_32X128X25",
    "B1_48X192X25",
    "B1_8X16X100",
    "B1_1X2X100",
    "B1_2X4X100",
    "B1_4X16X100",
    "B1_8X32X100",
    "B1_16X32X100",
    "B1_32X64X100",
    "B1_32X128X100",
    "B1_48X192X100",
    "BL1_1X2X100",
    "BL1_1X4X100",
    "BL1_2X4X100",
    "BL1_2X8X100",
    "BL1_4X8X100",
    "BL1_4X16X100",
    "BL1_8X16X100",
    "BL1_8X32X100",
    "BL1_16X32X100",
    "BL1_16X64X100",
    "BL1_32X64X100",
    "BL1_32X128X100",
    "BL2_1X2X100",
    "BL2_1X4X100",
    "BL2_2X4X100",
    "BL2_2X8X100",
    "BL2_4X8X100",
    "BL2_4X16X100",
    "BL2_8X16X100",
    "BL2_8X32X100",
    "BL2_16X32X100",
    "BL2_16X64X100",
    "BL2_32X64X100",
    "BL2_32X128X100",
    "C1_1X1X100",
    "C1_16X16X100",
    "C1_32X32X100",
    "C1_1X1X25",
    "C1_2X2X25",
    "C1_4X4X25",
    "C1_8X8X25",
    "C1_16X16X25",
    "C1_32X32X25",
    "C1_2X2X100",
    "C1_4X4X100",
    "C1_8X8X100",
    "M1_1X8X100",
    "M1_2X16X100",
    "M1_8X64X100",
    "M1_16X128X100",
    "M1_30X240X100",
    "M1_1X8X25",
    "M1_2X16X25",
    "M1_4X32X25",
    "M1_8X64X25",
    "M1_16X128X25",
    "M1_30X240X25",
    "M1_4X32X100",
)


class SoftLayerInstance(object):
    """Wrapper around a SoftLayer instance providing methods for testing.

    Methods provided simplify integration tests and validation.
    """

    _cloud_init_ran = False   # True oncecloud-init completes on the instance

    def __init__(self, instance, pubkey, client,
                 artifact_dir=REMOTE_ARTIFACT_DIR, verbose=False):
        """Initialize this helper class.

        @param instance: a SoftLayer instance dictionary.
        @param pubkey: Local path to the pubkey we'll use when contacting the
            instance.
        @param clienit: a SoftLayer.client()
        @param artifact_dir: The remote directory in which script results can
            be stored.  This value is provided via runcmd as an environemnt
            variable $SCRIPT_ARTIFACT_DIR.
        @param verbose: Boolean, set True to see commands sent to and from
            instance.
        """
        self.instance = instance
        self.pubkey = pubkey
        self.artifact_dir = artifact_dir
        self.verbose = verbose
        self.client = client
        self.vsmgr = SoftLayer.VSManager(client)

    def scp(self, source_path, dest_path):
        """Scp files or dirs to an instance."""
        instance_user_at_host = 'root@{}'.format(
            self.instance['primaryIpAddress'])
        source_path = source_path.replace('{INSTANCE}', instance_user_at_host)
        dest_path = dest_path.replace('{INSTANCE}', instance_user_at_host)
        cmd = ['scp', '-i', self.pubkey, '-o', 'StrictHostKeyChecking=no',
               '-o', 'UserKnownHostsFile=/dev/null', source_path, dest_path]
        check_output(cmd)

    def wait_for_ssh(self, timeout=180):
        start = time.time()
        tries = 1
        sys.stderr.write("Waiting for ssh.\n")
        while True:
            delta = time.time() - start
            if delta >= timeout:
                break
            # uses pipe_out to get 'proc' so we can use timeout and read rc.
            if tries != 1:
                sys.stderr.write("Checking ssh try %d (waited %ds/%d)\n" %
                                 (tries, delta, timeout))
            out, err, rc = self.runcmd(
                'cat /proc/uptime',
                ssh_opts=['-o', 'ConnectTimeout=2'], timeout=5)
            if rc == 0:
                up, _idle = out.decode('utf-8').split()
                sys.stderr.write(
                    "ssh up after %ds (uptime %s - %d tries)\n" %
                    (time.time() - start, up, tries))
                return
            tries += 1
            time.sleep(1)
        raise TimeoutError(
            "Timed out waiting for ssh to %s after %ds." %
            (self.instance['primaryIpAddress'], delta))

    def runcmd(self, command, ssh_opts=None, pipe_in=None, pipe_out=False,
               timeout=None):
        """Run a command over ssh on the instance.

        @param command: The string of command(s) to execute on the remote
            instance.
        @param pipe_in: Optional Popen process to take as stdin to the command.
        @param pipe_out: Optionally, whether to return the popen process
            spawned to allow subprocess.PIPEs to use the stdout of the command.
        """
        ip = self.instance['primaryIpAddress']
        if ssh_opts is None:
            ssh_opts = []
        stdin = None
        if pipe_in:
            stdin = pipe_in.stdout
        ssh_cmd = (
            ['ssh', '-i', self.pubkey, '-o', 'StrictHostKeyChecking=no', '-o',
             'UserKnownHostsFile=/dev/null'] +
            ssh_opts +
            ['root@{}'.format(ip), '--',
             'SCRIPT_ARTIFACT_DIR={}'.format(self.artifact_dir)])
        proc = Popen(ssh_cmd + [command], stdin=stdin, stdout=PIPE)
        if pipe_in:
            pipe_in.stdout.close()  # Allow p1 to receive SIGPIPE if p2 exits
        if pipe_out:
            return proc  # Caller needs to communicate and close
        out, err = proc.communicate(timeout=timeout)
        return out, err, proc.returncode

    def run_scripts(self, scripts_dir, artifacts_dir):
        """Push scripts_dir to the instance, run them and return artifacts.

        Provide SCRIPT_ARTIFACT_DIR env variable to scripts and copy any files
        in remote SCRIPT_ARTIFACT_DIR into local artifacts_dir.

        @param scripts_dir: Local path to a scripts directory which contains
            executable scripts which can be run by run-parts on the instance.
        @param artifacts_dir: Local path where script artifacts/results will be
            copied.
        """
        local_cmd = ['tar', '-czf', '-', scripts_dir]
        remote_artifact_basename = os.path.basename(self.artifact_dir)

        # Untar scripts_dir, run-parts scripts_dir, tar up self.artifact_dir
        remote_cmds = [
            'tar xzf - -C /tmp',
            'mkdir -p {0}'.format(self.artifact_dir),
            'SCRIPT_ARTIFACT_DIR={0} run-parts /tmp/{1}'.format(
                self.artifact_dir, scripts_dir),
            'tar -czf - -C /tmp {}'.format(remote_artifact_basename)]

        proc1 = Popen(local_cmd, stdout=PIPE)  # Tar up local scripts_dir
        # Perform all remote_cmds in a single ssh interaction.
        proc2 = self.runcmd(
            '; '.join(remote_cmds), pipe_in=proc1, pipe_out=True)
        # Untar self.artifact_dir locally
        proc3 = Popen(['tar', '-xzf', '-'], stdin=proc2.stdout, stdout=PIPE)
        proc2.stdout.close()
        out, err = proc3.communicate()
        # Move the remote_artifacts dirname to local artifacts_dir
        shutil.move(remote_artifact_basename, artifacts_dir)

    def wait_on_cloud_init(self):
        sys.stderr.write("Waiting on cloud-init\n")
        self._cloud_init_ran = True
        out, err, rc = self.runcmd("cloud-init status --wait")
        if rc != 0:
            raise TimeoutError("Failed waiting for cloud-init: %s." % err)

    def update_proposed_cloud_init(self):
        """Update cloud-init package to the version present in proposed."""
        sys.stderr.write("Enabling proposed and updating cloud-init.\n")
        self.runcmd(
            " rel=$(lsb_release -sc);"
            ' grep "deb .* $rel main" /etc/apt/sources.list |'
            ' sed "s/$rel/$rel-proposed/" > /tmp/cloud-init-proposed.list;'
            " sudo mv /tmp/cloud-init-proposed.list /etc/apt/sources.list.d/;"
            " sudo apt-get update;"
            " sudo DEBIAN_FRONTEND=noninteractive apt-get install cloud-init"
            " --yes")

    def clean(self, reboot=False):
        """Clean cloud-init artifacts from the system making it look 'new'.

        A cleaned system allows cloud-init to boot as if it is seeing the
        instance on first boot.
        """
        clean_cmd = 'sudo cloud-init clean --logs'
        self.runcmd(clean_cmd)
        self._cloud_init_ran = True
        if reboot:
            sys.stderr.write("Waiting for instance clean reboot\n")
            self.reboot()

    def destroy(self):
        """Stop and destroy the instance."""
        self.vsmgr.cancel_instance(self.instance['id'])

    def reboot(self, hard=False):
        """Stop and destroy the instance."""
        guest = self.client['Virtual_Guest']
        reboot = guest.rebootHard if hard else guest.rebootSoft
        reboot(id=self.instance['id'])
        sys.stderr.write("Issued reboot, now sleeping to give it time.\n")
        time.sleep(10)
        self.wait_for_ssh()
        self.wait_on_cloud_init()

    def start(self):
        """Start the instance."""
        self.instance.start()
        self.wait_on_cloud_init()

    def stop(self):
        """Stop the instance."""
        self.instance.stop()


def get_image_guid_by_name(client, name):
    """Return the newest image with given name."""
    imgr = SoftLayer.ImageManager(client)
    images = sorted(imgr.list_private_images(name=name),
                    key=image_datetime, reverse=True)
    guid = None
    if images:
        src = "private"
    else:
        src = "public"
        images = sorted(imgr.list_public_images(name=name),
                        key=image_datetime, reverse=True)

    if not images:
        raise RuntimeError(
            "No public or private images matching name '%s' found" % name)

    guid = images[0]['globalIdentifier']
    if len(images) > 1:
        print("Selected newest %s image '%s' created on '%s' from %d "
              "with name '%s'" %
              (src, guid, image_datetime(images[0]), len(images), name))
    print(images[0])

    return guid


def image_id_to_guid(image, client):
    try:
        uuid.UUID(image)
        return image
    except ValueError:
        pass

    # raise a ValueError for caller if not an integer or int as string
    int(image)
    image_mgr = SoftLayer.ImageManager(client)
    image_details = image_mgr.get_image(image, mask="id,globalIdentifier")
    return image_details['globalIdentifier']


def image_datetime(img):
    # create Date looks like 2016-10-24T10:45:25-05:00
    # replacing the ':' which arent easily handled in a timezone
    return datetime.datetime.strptime(
        img['createDate'].replace(":", ""), '%Y-%m-%dT%H%M%S%z')


def get_ubuntu_image_id(client, series_name, flavor):
    """Return a valid image id for the given series and region_name.

    Options can be seen in 'slcli image list'.
    """
    if series_name.startswith("template:"):
        series_name = series_name.partition(":")[2]
    # flavor is assumed to end with 'X<disk_size>'
    size = int(flavor.rpartition('X')[2])
    arch = "64"
    account = PUBLIC_IMAGE_ACCOUNT_ID
    version = UBUNTU_VERSIONS[series_name]
    # basically going to get the newest image that matches this template.
    # 25GB - Ubuntu / Ubuntu / 16.04-64 Minimal for VSI
    tmpl = "{size}GB - Ubuntu / Ubuntu / {version}-{arch} Minimal for VSI"
    imgr = SoftLayer.ImageManager(client)
    imgs = imgr.list_public_images(
        name=tmpl.format(size=size, version=version, arch=arch))
    imgs = [i for i in imgs if i['accountId'] == account]

    imgs = sorted(imgs, key=image_datetime, reverse=True)
    print(imgs[0])
    return imgs[0]['globalIdentifier']


def get_os_name(name):
    # translate 'os:xenial' to 'UBUNTU_16_64', os:OTHER to OTHER
    if name.startswith("os:"):
        name = name.partition(":")[2]
    s2v = {'precise': 'UBUNTU_12_64', 'trusty': 'UBUNTU_14_64',
           'xenial': 'UBUNTU_16_64', 'bionic': 'UBUNTU_18_64'}
    return s2v.get(name, name)


def get_parser():
    """Return an argument parser for this command."""
    parser = ArgumentParser(description=__doc__)
    parser.add_argument(
        '-i', '--image-id', type=str,
        help='Specify the image id to deploy. Use "template:<release>" to '
             'launch by well known template.  Or use ubuntu release name '
             '(%s), image id (integer), '
             'guid (uuid), or name' % list(UBUNTU_VERSIONS.keys()))
    parser.add_argument(
        '--deb-file', type=str, required=False, dest='deb_file',
        help='Provide a local deb for install on the instance')
    parser.add_argument(
        '--script-dir', type=str, dest='script_dir',
        help=('Specify a directory of scripts to run on the deployed instance.'
              ' Scripts should use SCRIPT_ARTIFACT_DIR env variable for'
              ' output.'))
    parser.add_argument(
        '--pubkey-file', required=False, type=str, dest='pubkey_file',
        default=os.path.expanduser('~/.ssh/id_rsa.pub'),
        help=('Specify a local directory where results of script output'
              ' artifacts are saved'))
    parser.add_argument(
        '--hostname', required=False, type=str, dest='hostname',
        default=None,
        help=('Specify the hostname.  Default is to generate with petname.'))
    parser.add_argument(
        '--script-artifacts-dir', type=str, dest='artifacts_dir',
        default=DEFAULT_LOCAL_ARTIFACT_DIR,
        help=('Specify a local directory where results of script output'
              ' artifacts are saved'))
    parser.add_argument(
        '-t', '--type', type=str, choices=FLAVORS,
        default=DEFAULT_FLAVOR,
        help='Specify a size/flavor to deploy')
    parser.add_argument(
        '--destroy', action='store_true', default=False,
        dest='destroy', help='Destroy system after running test.')
    parser.add_argument(
        '-p', '--proposed', action='store_true', default=False,
        help='Update instance cloud-init to the version in <series>-proposed.')
    parser.add_argument(
        '-r', '--region', type=str, choices=REGIONS,
        default=DEFAULT_REGION,
        help='Specify a region to deploy to [default=%s]' % DEFAULT_REGION)
    parser.add_argument(
        '-u', '--user-data-file', dest='user_data_file', type=str,
        help='Optional user-data file to run during instance initialization')
    parser.add_argument(
        '-s', '--series', type=str, default=DEFAULT_SERIES,
        choices=list(UBUNTU_VERSIONS.keys()),
        help='The default ubuntu series name to launch. [default={}]'.format(
                 DEFAULT_SERIES))
    parser.add_argument(
        '--list-ibm-images', action='store_true', default=False,
        help='show most recent images published by ibm.')
    parser.add_argument(
        '-v', '--verbose', action='store_true', default=False,
        help='Print more information about the operations performed.')
    parser.add_argument(
        '-c', '--clean', action='store_true', default=False,
        help=('Remove cloud-init artifacts and reboot system to re-run from'
              'a pseudo-clean system boot.'))
    return parser


def find_keypair_by(client, label=None, content=None):
    if label is None and content is None:
        raise ValueError("Empty label and content.")

    keymgr = SoftLayer.SshKeyManager(client)
    for key in keymgr.list_keys():
        if label and key.get('label') == label:
            return key
        if content and key.get('key') == content:
            return key

    return None


def import_keypair(client, key_path, name=None):
    """Create a new key if not present using the pubkey at key_path.

    @returns: dictionary of new key's info.
       {'id': int, 'fingerprint': 'aa:bb:...', 'label': name,
        'createDate': 2017-11-29T14:32:35-06:00, 'modifyDate'; string}
    """
    with open(key_path, 'r') as stream:
        key_material = stream.read().strip()
    toks = key_material.split()

    if name is None:
        if len(toks) == 3:
            name = toks[2]
        else:
            error("Did not find a comment/name in %s\n" % key_path)

    # you can't upload a key with the same label more than once.
    # so check to make sure this isnt already uploaded.
    existing = find_keypair_by(client, content=key_material)
    if existing:
        print("Using existing key with id=%s and label=%s and key"
              " matching content of %s" %
              (existing['id'], existing['label'], key_path))
        return existing

    print("Adding key with label %s and content from %s" % (name, key_path))
    keymgr = SoftLayer.SshKeyManager(client)
    return keymgr.add_key(key_material, label=name)


def create_secgroup(client, sec_group_name=None, source_cidr=None):
    """Create cloud-init's test sec group with ssh ingress from source_cidr."""

    # FIXME
    #  http://softlayer-api-python-client.readthedocs.io/en/latest/api/managers/network/
    return None


def is_local_disk_flavor(flavor):
    # the python client sends 'local_disk' always, and if that
    # is inconsistent with the flavor, then it will fail to launch.  so you
    # have to "know" the correct value.
    return flavor.startswith('BL')


def create_instance(client, image, keyname, flavor=None,
                    region=None,
                    hostname=None, security_groups=None, user_data_file=None):
    """Create and instance and wait for started state."""

    opts = {'domain': 'testing.ci.cloud-init.org'}

    if flavor is None:
        flavor = DEFAULT_FLAVOR

    if hostname is None:
        hostname = 'ci-' + petname.generate()

    if region is None:
        region = DEFAULT_REGION

    userdata = None
    if user_data_file:
        if not os.path.exists(user_data_file):
            raise RuntimeError(
                'user-data file {} does not exist'.format(user_data_file))
        with open(user_data_file, "r") as stream:
            userdata = stream.read()

    # if keyname is an int, then its assumed an ID. otherwise look up by name.
    try:
        ssh_keys = [int(keyname)]
    except TypeError:
        ssh_keys = find_keypair_by(client, label=keyname)['id']

    opts.update({
        'local_disk': is_local_disk_flavor(flavor), 'flavor': flavor,
        'ssh_keys': ssh_keys,
        'hostname': hostname,
        'datacenter': region,
        'userdata': userdata,
        }
    )
    if image in UBUNTU_VERSIONS or image.startswith("os:"):
        # if image is simply 'xenial' or 'bionic', then launch by os_code.
        # that is the newer config-2 style launch.
        # Get a list with:
        # opts = vsmgr.get_create_options()
        # [k['template']['operatingSystemReferenceCode']
        #    for k in opts['operatingSystems']]
        opts['os_code'] = get_os_name(image)
    elif image.startswith("template:"):
        # 'template:xenial' gets converted to well known public template name.
        # image is 'os:' meaning launch by 'os' (os:UBUNTU_16_64)
        opts['image_id'] = get_ubuntu_image_id(client, image, flavor)
    else:
        try:
            # this handles int or actual guid.
            opts['image_id'] = image_id_to_guid(image, client)
        except ValueError:
            opts['image_id'] = get_image_guid_by_name(client, image)

    if security_groups is not None:
        opts['public_security_groups'] = security_groups

    vsmgr = SoftLayer.VSManager(client)
    print("opts=%s" % opts)
    start = time.time()
    instance = vsmgr.create_instance(**opts)

    print('Waiting for instance initialization (%s)' % instance['id'])
    printed_addr = False
    last_status = None
    while True:
        data = vsmgr.get_instance(instance['id'])
        if not printed_addr and data.get('primaryIpAddress'):
            if last_status:
                sys.stdout.write("\n")
                last_status = None
            print("primary ip: %s" % data['primaryIpAddress'])
            printed_addr = True

        status = data.get('activeTransaction', {}).get(
            'transactionStatus', {}).get("name", "no-status")
        if status == last_status:
            sys.stdout.write(".")
        else:
            if last_status:
                sys.stdout.write("\n")
            sys.stdout.write(
                "[%3ds] %s" % (int(time.time() - start), str(status)))
        sys.stdout.flush()

        last_status = status

        if is_ready(data):
            if status != "SERVICE_SETUP":
                sys.stderr.write(" [is_ready=True status=%s]" % status)
            sys.stderr.write("\n")
            finish = time.time()
            break
        time.sleep(5)

        # print(json.dumps(data, indent=1) + "\n")

    data = vsmgr.get_instance(instance['id'])
    print("\nGot %s at %s.  took %.2f seconds" % (
          data['id'], data['primaryIpAddress'],
          (finish - start)))
    return data


def error(message):
    sys.stderr.write('ERROR: {0}\n'.format(message))
    sys.exit(1)


def list_images(client, account=PUBLIC_IMAGE_ACCOUNT_ID, newest=True):
    def imgkey(i):
        # if image has a starts with '100GB -' or '25GB -' then
        # take that off so it groups with other images of its os type.
        # 25GB - Ubuntu / Ubuntu  / 10.04-32 Minimal for VSI
        if i['name'].startswith("25GB -") or i['name'].startswith("100GB -"):
            name = "{2} - {0}".format(*i['name'].partition("-"))
        else:
            name = i['name']
        return (name, image_datetime(i))

    imgr = SoftLayer.ImageManager(client)
    imgs = [i for i in imgr.list_public_images()
            if i['accountId'] == account]

    printed = set()

    fmt = "{id!s:>7s} {globalIdentifier:36s} {ymd:10s} {name}"
    print(fmt.format(id="id", globalIdentifier="guid", ymd="created",
          name="name"))
    for i in sorted(imgs, key=imgkey, reverse=True):
        if newest and i['name'] in printed:
            continue
        i['ymd'] = datetime.datetime.strftime(image_datetime(i),
                                              "%Y-%m-%d-%H%M%S")
        print(fmt.format(**i))
        printed.add(i['name'])


def main():
    parser = get_parser()
    args = parser.parse_args()
    if not os.path.isfile(args.pubkey_file):
        error("--pubkey-file=%s: not a file\n" % args.pubkey_file)
    image_id = args.image_id
    if not image_id:
        image_id = args.series
    client = SoftLayer.Client()
    try:
        secgroup = create_secgroup(client)
    except SoftLayer.exceptions.SoftLayerAPIError as e:
        sys.argv = ["slcli", "config", "setup"]
        sys.stderr.write("%s\n\n" % e)
        sys.stderr.write(
            "Looks like credentials are bad.\n"
            "Attempting to run '%s' to configure ~/.softlayer\n\n"
            "First click the generate link @ %s"
            "Get your API Username and Key from:\n  %s\n\n" %
            (' '.join(sys.argv),
             "https://control.softlayer.com/account/users",
             "https://control.softlayer.com/account/user/profile"))
        from SoftLayer.CLI.core import main
        main()
        sys.exit(1)  # just because we did not launch an instance.

    if args.list_ibm_images:
        list_images(client)
        sys.exit(0)
    keypair = import_keypair(client, args.pubkey_file)
    inst = create_instance(
        client, image_id, keyname=keypair['id'], hostname=args.hostname,
        region=args.region,
        flavor=args.type,
        security_groups=secgroup, user_data_file=args.user_data_file)

    instance = SoftLayerInstance(inst, args.pubkey_file, client)
    if args.deb_file:
        instance.scp(args.deb_file, '{INSTANCE}:.')
        deb_filename = os.path.basename(args.deb_file)
        instance.runcmd('sudo apt-get install --yes python3-jsonschema;'
                        ' sudo dpkg -i ./{}'.format(deb_filename))
    if args.proposed:
        instance.update_proposed_cloud_init()
    if args.clean:
        sys.stderr.write("Cleaning system\n")
        instance.clean(reboot=True)
    if args.script_dir:
        sys.stderr.write("Executing scripts from %s\n" % args.script_dir)
        instance.run_scripts(args.script_dir, args.artifacts_dir)
    if args.destroy:
        instance.destroy()
    else:
        sys.stderr.write(
            "Destroy instance with:\n  slcli virtual cancel %s\n" % inst['id'])
    return 0


if __name__ == "__main__":
    sys.exit(main())
